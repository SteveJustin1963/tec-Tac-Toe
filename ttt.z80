; Tic-Tac-Toe for JMON
; Modified to work with JMON's keyboard input and specific circuit display

; Constants
DISPLAY_DATA    EQU 0x02  ; Port for display data (connected to 8212)
DISPLAY_SELECT  EQU 0x01  ; Port for display select (connected to 74LS138)
INPUT_PORT      EQU 0x00  ; Port for keyboard input (74C923)

; RAM Variables
    ORG 0x8000
board:          DS 9    ; Tic-tac-toe board (0 = empty, 1 = player, 2 = CPU)
current_player: DS 1    ; 1 = player, 2 = CPU
cursor:         DS 1    ; Current cursor position (0-8)

    ORG 0x0000
    JP main

main:
    ; Initialize the game
    CALL init_game
game_loop:
    CALL display_board
    LD A, (current_player)
    CP 1
    JP Z, player_turn
    CALL cpu_turn
    JP check_game_over

player_turn:
    ; Wait for input (using JMON's RST 10)
    RST 0x10
    AND 0x1F  ; Mask off unused bits
    CP 16     ; Check if input is valid (0-15 for this keypad)
    JP NC, player_turn  ; If >=16, invalid input, try again
    CP 9      ; We only use 0-8 for Tic-Tac-Toe
    JP NC, player_turn  ; If >=9, invalid input, try again
    LD (cursor), A
    ; Check if the move is valid
    LD HL, board
    LD C, A
    LD B, 0
    ADD HL, BC
    LD A, (HL)
    CP 0
    JP NZ, player_turn  ; Invalid move, try again
    ; Make the move
    LD (HL), 1
    JP check_game_over

cpu_turn:
    ; Simple AI: choose the first empty space
    LD HL, board
    LD B, 9
cpu_loop:
    LD A, (HL)
    CP 0
    JP Z, cpu_move_found
    INC HL
    DJNZ cpu_loop
    RET  ; No moves available (shouldn't happen)

cpu_move_found:
    LD (HL), 2
    RET

check_game_over:
    ; Check for a win or draw (not implemented in this simple version)
    ; For now, just switch players
    LD A, (current_player)
    CP 1
    JP Z, set_cpu_turn
    LD A, 1
    LD (current_player), A
    JP game_loop

set_cpu_turn:
    LD A, 2
    LD (current_player), A
    JP game_loop

init_game:
    ; Clear the board
    LD HL, board
    LD B, 9
    XOR A
clear_loop:
    LD (HL), A
    INC HL
    DJNZ clear_loop
    ; Set initial values
    LD A, 1
    LD (current_player), A
    XOR A
    LD (cursor), A
    RET

display_board:
    ; Display the current board state on the 7-segment displays
    LD B, 6  ; Display 6 cells (2 rows of the board)
    LD C, 0  ; Start with the first display
display_loop:
    LD A, C
    OUT (DISPLAY_SELECT), A  ; Select the display
    LD A, C
    LD HL, board
    CALL get_board_state
    CALL convert_to_7seg
    OUT (DISPLAY_DATA), A    ; Output the segment data
    INC C
    DJNZ display_loop
    RET

get_board_state:
    ; Input: A = display number (0-5)
    ; Output: A = board state (0, 1, or 2)
    ; Converts display number to board position
    CP 3
    JR NC, bottom_row
    ; Top row
    ADD A, 0  ; No change for top row
    JR get_state
bottom_row:
    ADD A, 3  ; Adjust for bottom row
get_state:
    LD C, A
    LD B, 0
    ADD HL, BC
    LD A, (HL)
    RET

convert_to_7seg:
    ; Convert board state to 7-segment LED pattern
    ; 0 (empty) = 0x00
    ; 1 (player) = 0x06 (segment pattern for '1')
    ; 2 (CPU) = 0x5B (segment pattern for '2')
    CP 0
    JR Z, empty_cell
    CP 1
    JR Z, player_cell
    ; Must be 2 (CPU)
    LD A, 0x5B
    RET
empty_cell:
    XOR A  ; LD A, 0
    RET
player_cell:
    LD A, 0x06
    RET
